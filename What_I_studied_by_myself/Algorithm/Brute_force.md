# 📚 완전탐색

## 📘 이론

### 정의

- 모든 경우의 수를 다 해보는 법
- Brute-Force(무식하게 풀기)
- 컴퓨터의 빠른 계산 능력을 이용하는 알고리즘

### 대표적인 알고리즘

- 순열, 백트래킹, BFS

### 완전 탐색 구현 과정

1. 가능한 모든 가짓수를 계산한다.
   - 문제에서 주어지는 입력, 출력 제한이 중요하다.

2. 어떤 식으로 구현을 할 지 생각한다.
   - 단순한 문제라면 for문을 사용하고,
   - 순서를 파악한다면 순열을 사용하며,
   - 계산을 하면서 중간값이 결과값과 먼 경우, 가지치기를 해야하는 경우 백트래킹을 해야할 수 있다.

3. 답 구하기

### 시간 계산

- 완전 탐색 방법은 어떻게 푸느냐보다 얼마나 걸리느냐를 먼저 파악해야 하는 알고리즘이기 때문에 빠르게 시간계산을 할 필요가 있다.
- 가장 큰 입력범위를 넣었을때 보통 1억번의 연산이 1초정도로 계산된다.

#### 시간복잡도

O(N) : 1억

O(NlogN) : 5백만

O(N**2) : 1만

O(N!) : 11



## 📒 코드

### 단순 for문

- 포커 카드 N장 중 2장을 골라 두 장의 합이 M에 최대한 가까운 합을 구하시오

- N장 중 2장고르기 -> nC2

  ``` python
  N, M = map(int, input().split())
  sumV = 0
  res = 0
  for i in range(N):
      for j in range(N):
          sumV = i + j
          if abs(M - res) > abs(M - sumV):
              res = sumV
  
  print(res)
  ```

  - 하지만 n이 10만 이상이라면 위와 같이 접근시 1초제한 문제에서는 시간 초과가 발생한다.



---

### 순열

- 서로 다른 n개의 원소에서 r개를 중복없이 골라 순서대로나열하는 경우의 수

- P, N의 정수로 이루어진 순열 중 사전순으로 M 번째 위치한 순열은?
  - 모든 순열의 가짓수는 N!
  - O(N!) 
    - 1초 제한인 문제에서는 시간 초과

​	``` python 

```python
# 1. 재귀를 이용한 구현 - 원소를 하나씩 뽑아서 수열을 구성하고 출력한다.

def permutation(arr, r):
    arr = sorted(arr)
    used = [0 for _ in range(len(arr))]

    def generate(chosen, used):
        if len(chosen) == r:
            print(chosen)
            return

        for i in range(len(arr)):
            if not used[i]:
                chosen.append(arr[i])
                used[i] = 1
                generate(chosen, used)
                used[i] = 0
                chosen.pop()
    generate([], used)

permutation('ABCDE', 2)
# permutation([1, 2, 3, 4, 5], 3)
```

​	

---

### 조합

- 서로다른 n개의 원소 중 r개를 순서없이 골라낸 것을 조합(combination)이라고 부른다.

- 재귀를 이용하여 구현한다.



---

### 부분집합

- 집합에 포함된 원소들을 선택하는 것이다.
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것이다.
- N개의 원소를 포함한 집합
  - 자기 자신과 공집합 포함한 모든 부분집합(power set)의 개수는 2 ** n 개
  - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가 (복잡도가 커진다.)
  - n이 작은 경우 사용한다. (n의 범위 확인하기)



#### 바우너리 카운팅을 통한 사전적 순서(Lexicographic Order)

- 부분집합을 생성하기 위한 가장 자여스러운 방법
- **바이너리 카운팅**은 **사전적 순서로 생성**하기 위한 가장 간단한 방법이다.
- **사용방법**
  - 주어진 리스트의 모든 부분집합을 출력해보자.
  - 각각의 원소들을 2진수로 나타내어 리스트에 담는다. 
  - **1이라고 적힌 부분의 index**를 사용한다.
  - index에 접근하여 주어진 리스트에서 뽑아내면 된다.
  - 10진수를 2진수로 바꿔주고 2진수로 바꾼 원소들의 해당 자리의 인덱스를 살펴보고, 해당 자리의 인덱스에 맞게 주어진 리스트에 접근하면 된다
    - 10진수, 2진수, {A,B,C,D}
    - 1, 0001, {A}인셈이다
    - 이 때 배열은 순서를 반대로 접근하므로 혼동하지 않도록 주의한다.
    - **뒤 쪽에서 앞으로** 읽어나간다.
