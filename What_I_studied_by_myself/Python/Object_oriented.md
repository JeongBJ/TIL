# 객체지향

객체지향 프로그래밍은 대규모  프로그램을 효율적으로 코딩할 수 있게 해준다.



## 객체지향의 이해

### 객체지향 프로그래밍 (Object-Oriented Programming)

- 프로그램의 로직을 상태와 행위로 이루어진 객체로 만든 다음 해당 객체를 조립하여 하나의 프로그램을 만드는 것이다.

- 객체를 이용해 문제를 해결하려는 프로그래밍 방법이다.

#### 객체란?

- 변수와 메서드를 하나로 묶은 것이다.
- 변수는 값을 가지며 메서드는 실행할 코드를 가진다. 
- 변수와 메서드를 서로 연관된 것들끼리 묶어 만든 것이 바로 객체이다.
  - 변수와 연관된 기능이 메서드에 해당한다.

- 객체지향에서는 **서로 연관된 변수와 메서드를 잘 파악하고 묶어 객체를 형성하는 것이 중요**하다.
- 결국 객체지향은 객체를 부품으로 잘 조립해만든 레고블록과 비슷하며
- 이러한 부품은 한 군데에서만 사용하는 것이 아니라 여러군데에서 재사용할 수 있다. 
- **부품화**와 **재사용성**은 **객체지향의 가장 중요한 특징**이다.

### 객체지향의 구성요소

#### 클래스(Class)

- 같은 문제 도메인에 속하는 속성(attribute)과 행위(behavior)를 정의한 것이다.
- 객체지향 프로그램의 기본적인 사용자 정의 데이터 타입이다. 

#### 객체(Object)

- 객체란 메모리에 로딩된 클래스를 통해 클래스를 템플릿으로 하여 메모리 상에 생성된 정보다.
- 인스턴스라고 부르기도 한다.
- 객체는 자신 고유의 속성을 가지며 클래스에서 정의한 행위를 수행한다.
- 객체의 행위는 클래스에서 정의된 행위에 대한 정의를 공유함으로서 메모리를 효율적으로 사용한다.

#### 메서드(Method)

- 메시지(Message)라고도 부른다.
- 클래스로부터 생성된 객체를 사용할 시 객체에 명령을 내리는 행위다.
- 이 때 이 행위를 '객체가 가지고 있는 메서드를 호출한다' 혹은 '객체에 메시지를 전달한다'라고 표현한다.
- 한 객체의 속성을 조작할 목적으로 사용된다.
- 객체 간의 통신은 메세지 전달을 통해 이루어진다.



### 객체지향 프로그램의 특징

#### 추상화

- 객체에서 **공통된 속성과 행위**를 찾아서 타입을 정의하는 과정이다.
- 추상화를 통해 정의된 타입을 추상데이터 타입이라고 한다.
- 데이터 타입의 표현과 연산을 캡슐화한다.
- 접근 제어를 통해 데이터의 정보를 은닉할 수 있다.
- 객체지향 프로그램에서 일반적으로 추상데이터 타입을 클래스, 추상 데이터 타입의 인스턴스를 객체, 추상 데이터 타입에서 정의된 연산을 메서드라고 한다.

#### 상속

- 클래스의 속성과 행위를 하위 클래스에 물려주거나 상위 클래스에서 물려받는 것으로 
- 새로운 클래스가 기존의 클래스의 데이터와 연산을 이용할 수 있게 하는 기능이다. 
- 상속을 받는 새로운 클래스를 **자식 클래스, 파생 클래스, 하위 클래스, 서브 클래스**라고 한다.
- 새로운 클래스가 상속하는 기존의 클래스를 **부모 클래스, 기반 클래스, 상위 클래스, 슈퍼 클래스**라고 한다.
- 상속받은 하위클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있다.
- 클래스 간의 종속 관계를 형성하여 객체를 조직화 할 수도 있다.

##### 상속의 장점

- 재사용으로 인해 코드가 줄어든다.
- 범용적인 사용이 가능하다.
  - object 타입의 매개변수에는 string이나 int의 객체가 쓰여도 문제되지 않는다.
    - string과 int 모두 object를 상속받기 때문이다.
- 자료와 메서드의 자유로운 사용 및 추가 기능

#### 다형성

- 다양한 형태로 나타날 수 있는 특징을 의미한다.
- 객체지향 프로그래밍은 하나의 클래스 내부에 같은 이름의 행위를 여러개 정의하거나 상위 클래스의 행위를 하위클래스에서 재정의하여 사용할 수 있기에 다형성이라는 특징을 가지게 된다.
- 다형성이란 **어떤 한 요소에 여러 개념을 넣어 놓는 것**으로 **오버라이딩과 오버로딩**을 의미한다.
- **오버라이딩**이란 같은 이름의 메서드가 여러 클래스에서 다른 기능을 하는 것이다.
- **오버로딩**이란 같은 이름의 메서드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것이다.

##### 메서드 오버라이딩

- 상속으로 물려받은 자료나 메서드를 그대로 사용하지 않고 하위 클래스에서 새로 정의해 사용하는 기법이다.
- 상위 클래스의 메서드와 동일한 서명(매개변수의 타입, 개수, 리턴타입)을 가져야 한다.

##### 메서드 오버로딩

- 클래스 내부에 동일한 이름의 행위를 여러 개 정의하는 것이다.
- 메서드의 이름이 같고, 매개변수의 타입과 수는 서로 달라야 한다.
- 리턴 타입은 관계하지 않는다.
- 메서드 이름을 하나로 통일 가능하며, 같은 이름의 메서드에 여러 종류의 매개 변수를 받을 수 있다.



## 클래스 정의

### 클래스

- 객체 생성을 위한 청사진 또는 템플릿이다.

### 클래스 정의 및 객체 생성

#### 클래스 정의

- class 클래스명 :

  ...

#### 객체생성

- 변수 = 클래스명() 
  - 생성자 메서드 : 클래스 이름과 동일한 메서드

### 객체의 생성과 소멸, 그리고 self

#### 생성자 메서드 : 객체를 생성하기 위해 호출하는 메서드

- 생성자 메서드를 실행하면 __ init __ 메서드가 실행된다.

- 클래스 생성자 메서드 정의

  ``` python
  class 클래스명 :
      def __init__(self, 매개변수목록);
      	...
  ```

  

#### 소멸자 메서드 : 객체가 소멸되기 전에 호출되는 메서드

- 소멸자 메서드를 실행하면 __ del __ 메서드가 실행된다.

- 클래스 소멸자 메서드 정의

  ``` python
  class 클래스명:
      ...
      def __del__(self):
          ...
  ```

  - self 를 제외한 매개변수는 사용하지 않는다.
  - self는 클래스에 의해 생성된 객체 공간을 가리키는 식별자
  - 객체공간의 필드와 메서드에 접근할 경우 self.식별자 형식을 이용한다.



``` python
class Person:
    def __init__(self, name, age): # self가 가리키는 객체 공간에 name, age 필드를 생성한다.
        self.name = name
        self.age = age
        print("{0} 객체가 생성되었습니다.".format(self.name))
        
    def __del__(self): # 매개변수 self에는 객체공간의 참조가 전달된다.
        print("{0} 객체가 제거되었습니다.".format(self.name))
        
```



## 클래스와 인스턴스의 특징

### 인스턴스 메서드

- self가 가리키는 객체의 필드 정보에 접근해 특정 목적의 기능을 수행하도록 정의된 메서드

### 인스턴스 변수

- 클래스 내에서 **self.변수** 형태를 가지는 변수
- 객체마다 가지고 있는 객체 고유의 정보다.

#### 인스턴스 변수의 접근 제한 기능

- 언더스코어 두 개를 기술하여 프라이빗 필드를 생성한다.

  ``` python
  class Person:
      ...
      self.__name = name
      # 프라이빗 필드 생성
  ```

  - 프라이빗 필드 생성 시 해당 필드에 대해 외부에서 접근할 수 있는 공개된 getter/setter 메서드를 제공할 것인지 등을 고려해야 한다.
  - getter : 멤버를 읽어오는 메서드
  - setter : 멤버를 변경하는 메서드

#### 데코레이터(decorator) 기능

- 변수이름과 같은 메서드를 만들어 사용할 수 있다.

- 모습은 메서드이지만 변수처럼 사용할 수 있다.

  ``` python
  class Person:
      ...
      	@propterty #(혹은 @property의이름.setter)
          def name(self):
  ```

### 클래스 변수

- 클래스 변수는 클래스 내에서 self가 아닌 **클래스명.변수** 형식으로 선언된 변수

#### 클래스 변수 정의

``` python
class  클래스명:
    클래스변수 = 값
    ...
```

#### 클래스 변수 접근

- 클래스명.클래스변수

``` python
class Person:
    count = 0
    
    def __init__(self, name, age): #객체가 생성될 때마다 호출되는 __init__메서드
        self.__name = name
        self.__age = age
        Person.count += 1
        print("{0} 객체가 생성되었습니다.".format(self.__name))
        
    def __del__(self):
        print("{0} 객체가 제거되었습니다.".format(self.__name))
       
    def to_str(self):
        return "{0}\t{1}".format(self.__name, self.__age)
    
    @property
    def name(self):
        return self.__name
    
    @property
    def age(self):
        return self.age
    
    @age.setter
    def age(self, age):
        if age < 0:
            raise TypeError("나이는 0 이상의 값만 허용합니다.")
        self.__age = age
        
people = [
    Person("홍길동", 20),
    Person("이순신", 45),
    Person("강감찬", 35)
]

print("현재 Person 클래스의 인스턴스는 총 {0}개 입니다.".format(Person.count))
# 현재 Person 클래스의 인스턴스는 총 3개 입니다.
```



### 클래스 메서드

- 클래스가 소유한 메서드

#### 클래스 메서드 정의

``` python
class 클래스명:
    ...
    @classmethod
    def 클래스메서드(cls, 매개변수목록): #cls는 클래스 자신에 대한 참조를 전달
```

#### 클래스 메서드의 사용

- 클래스명. 클래스메서드(매개변수목록)



### 연산자 오버로딩

``` python
...
	@classmethod
    def get_info(cls):
        return "현재 Person 클래스의 인스턴스는 총 {0} 개입니다.".format(cls.count)
    
    def __gt__(self, other):
        return self.__age > other.__age # self의 __age필드가 other 객체의 __age 필드보다 크면 true 반환
    
    def __ge__(self, other):
        return self.__age >= other.__age # self의 __age 필드가 other 객체의 __age 필드보다 크거나 같으면 true 반환
    
    def __lt__(self, other):
        return self.__age < other.__age # self의 __age 필드가 other 객체의 __age 필드보다 작으면 true 반환
```



## 클래스 상속

- 부모 클래스의 동작을 자식클래스에서 재사용, 확장, 수정하는 것을 의미한다.

  - 여기서 부모 클래스는 멤버가 상속되는 클래스이며, 자식 클래스는 멤버를 상속하는 클래스다.
  - 파이썬에서는 단일 상속만 지원한다.

- 클래스 상속

  ``` python
  class 클래스명(부모클래스명):
  ```

  

### 메서드 오버라이딩

- 부모 클래스에 있는 메서드와 **동일한 서명을 가진 메서드를 자식 클래스에서 다시 정의해 **사용하는 것이다.